% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fuzz.R
\name{fuzz}
\alias{fuzz}
\title{Fuzz-test the specified functions}
\usage{
fuzz(
  funs,
  what = test_inputs(),
  package = NULL,
  listify_what = FALSE,
  ignore_patterns = "",
  ignore_warnings = FALSE
)
}
\arguments{
\item{funs}{A character vector of function names to test. If a \code{"package"}
attribute is set and is no \code{package} argument is provided, functions
are loaded from the namespace specified in the attribute.}

\item{what}{A list of objects to be passed, one at a time, as the first
argument to each function in \code{funs}. Ideally, the list should be
named, so that each input can be pretty-printed with its
corresponding name; function \link{namify} provides an automatic way to
create a named list. For unnamed lists, a deparsed representation of
the inputs will be used, which may appear unwieldy in some cases.
If no inputs are provided, a default set of inputs generated by
\link{test_inputs} will be used.}

\item{package}{A character string specifying the name of the package to
search for functions. If \code{NULL} (default), the function will first
check the \code{"package"} attribute of \code{funs}, and if that is not set,
names will be searched in the global namespace.}

\item{listify_what}{Whether each input in \code{what} should also be tested
in its listified version (\code{FALSE} by default). When set to \code{TRUE},
if \code{what} is \code{list(x = x)}, the function will operate as if it
were \code{list(x = x, "list(x)" = list(x))}, for any input object \code{x}.}

\item{ignore_patterns}{One or more strings containing regular expressions
to match the errors to ignore. The string "is missing, with no
default" is always ignored.}

\item{ignore_warnings}{Whether warnings should be ignored (\code{FALSE} by
default).}
}
\value{
An object of class \code{cbtf} that stores the results obtained for each of the
functions tested. This contains the following fields:
\item{runs}{a list of data frames, each containing the results of fuzzing
all the functions in \code{funs} with one of the inputs in \code{what}. The
data frame contains the following columns and attributes:\cr
- \code{res}: The result of the fuzz test, see below for the possible
values.\cr
- \code{msg}: The error or warning message returned by the function, if
any.\cr
- \verb{attr(*, "what")}: The character representation of the input
tested.
}
\item{funs}{a vector of names of the functions tested.}
\item{package}{a character string specifying the package name where
function names were searched, or \code{NA} if none was provided.}
\item{ignore_patterns}{The value of the \code{ignore_patterns} argument.}
\item{ignore_warnings}{The value of the \code{ignore_warnings} argument.}

The \code{res} column in each of the data frames in the \verb{$runs} field can
contain the following values:
\itemize{
\item \strong{OK}: either no error or warning was produced (in which case, the \code{msg}
entry is left blank), or it was whitelisted (in which case, the message
received is stored in \code{msg}).
\item \strong{SKIP}: no test was run, either because the given name cannot be found, or
it doesn't correspond to a function, or the function accepts no arguments;
the exact reason is given in \code{msg}.
\item \strong{WARN}: a warning was thrown for which no whitelisting occurred and
\code{ignore_warnings = FALSE}; its message is stored in \code{msg}.
\item \strong{FAIL}: an error was thrown for which no whitelisting occurred; its message
is stored in \code{msg}.
}
}
\description{
The fuzzer calls each function in \code{funs} with each object in \code{what} and
records any errors or warnings that are thrown. If no error occurs within
the first 2 seconds, the execution of the function being fuzzed is stopped
and the next one is started.
}
\details{
The implementation uses \code{mirai} as a backend, which allows to run functions
asynchronously in parallel processes. Therefore, persistent background
processes (daemons) should be made available before the start of fuzzing;
the function will check for their presence and not run otherwise. This can
be done with the \link{daemons} function, which allows to control the number of
processes to use.
}
\section{Whitelisting}{


In order to reduce the number of false positive results produced, this
function applies the following set rules, to establish if an error or
warning condition should ignored (whitelisting):
\itemize{
\item If the name of the function appears in the error or warning message, as
it is considered that the condition has been handled by the developer.
\item If the error or warning message contains the text "is missing, with no
default", which is produced when a missing argument is used without a
value being assigned to it.
\item If the error or warning message contains any of the patterns specified
in \code{ignore_patterns}.
\item If a warning is thrown but \code{ignore_warnings = TRUE} is set.
}

In all whitelisted cases, the result is "OK", and the message that
was received is stored in the \verb{$msg} field (see the \emph{Value} section).

\emph{Note:} Whitelisting can also be applied post-hoc on the results of a fuzz
run using the \link{whitelist} function.
}

\examples{
## set up persistent background processes
daemons(2)

## this should produce no errors
res <- fuzz(funs = c("list", "matrix", "mean"),
            what = test_inputs(c("numeric", "raw")))
summary(res)

## display all results even for successful tests
print(res, show_all = TRUE)

## this will catch an error (false positive)
fuzz(funs = "matrix",  what = test_inputs("scalar"))

## close the background processes
daemons(0)

}
\seealso{
\link{get_exported_functions}, \link{test_inputs}, \link{namify}, \link{whitelist},
\link{summary.cbtf}, \link{print.cbtf}
}
